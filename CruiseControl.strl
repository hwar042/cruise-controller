% Main Module %
module CruiseControl:

% Inputs %
input On, Off, Resume, Set, QuickDecel, QuickAccel;
input Accel : float;
input Brake : float;
input Speed : float;

% Outputs %
output CruiseSpeed : float;
output Throttle : float;
output CruiseState : integer;
% 1:OFF 2:ON 3:STDBY 4:DISABLE %

signal state : integer in
	[loop
		present state then
			emit CruiseState(?state);
			end present;
			pause;
	end loop]
	||
    run CruiseFSM [ signal On/On_CSC;
                    signal Off/Off_CSC;
                    signal Resume/Resume_CSC;
                    signal Accel/Accel_CSC;
                    signal Brake/Brake_CSC;
                    signal state/State_CSC;
                    signal Speed/Speed_CSC ]
	||
	run CruiseSpeedController[ signal Set/Set2;
							   signal QuickDecel/QuickDecel2;
							   signal QuickAccel/QuickAccel2;
							   signal Accel/Accel2;
							   signal state/CruiseState2;
							   signal Speed/Speed2;
							   signal CruiseSpeed/CruiseSpeed2  ]
	||
	run ThrottleController[ signal Accel/Accel_driving;
							signal CruiseSpeed/CruiseSpeed_driving;
							signal state/State_driving;
							signal Speed/Speed_driving;
							signal Throttle/Throttle_driving ]
end signal

end module

% SubModules %

module CruiseFSM:
constant PedalsMin : float;
constant SpeedMin : float;
constant SpeedMax : float;

input On_CSC;
input Off_CSC;
input Resume_CSC;
input Accel_CSC : float;
input Brake_CSC : float;
input Speed_CSC : float;

output State_CSC : integer;

    % OFF-1 ON-2 STDBY-3 DIS-4
    var state := 1 : integer in
        loop
            emit State_CSC(state);
            pause;
            trap T2 in %Look into traps

                % State - Off
                if state = 1 then
                    present On_CSC then
                        state := 2; exit T2;
                    end present;
                end if;

                % State - On
                if state = 2 then
                    present Off_CSC then 
                        state := 1;
                    end present;
                    if ?Accel_CSC > PedalsMin then
                        state := 4; 
                        exit T2;
                    end if;
                    if ?Speed_CSC < SpeedMin then
                        state := 4; 
                        exit T2;
                    end if;
                    if ?Speed_CSC > SpeedMax then
                        state := 4; 
                        exit T2;
                    end if;
                    if ?Brake_CSC > PedalsMin then
                        state := 3; 
                        exit T2;
                    end if;
                    exit T2;
                end if;

                % State - Standby
                if  state = 3 then
                    present Off_CSC then 
                        state :=1;
                    end present;
                    present Resume_CSC then
                        if (?Speed_CSC>SpeedMin) and (?Speed_CSC<SpeedMax) then
                            state := 2;
                            exit T2;
                        end if;
                        if ?Accel_CSC > PedalsMin then
                            state := 4; 
                            exit T2;
                        end if;
                        if ?Speed_CSC>SpeedMax then
                            state := 4; 
                            exit T2;
                        end if;
                        if ?Speed_CSC<SpeedMin then
                            state := 4; 
                            exit T2;
                        end if;
                    end present;
                    exit T2;
                end if;

                %State - Disable
                if state = 4 then
                    present Off_CSC then 
                        state :=1;
                    end present;
                    present On_CSC then
                         if (?Accel_CSC < PedalsMin) and (?Speed_CSC<SpeedMax) and (?Speed_CSC>SpeedMin) then
                            state := 2; 
                            exit T2;
                        end if;
                    end present;
                    exit T2;
                end if;
            end trap
        end loop
    end var
end module

module CruiseSpeedManagement:

constant SpeedMini : float;
constant SpeedMaxi : float;
constant SpeedInc : float;
constant Zero : float;

input Set2;
input QuickDecel2;
input QuickAccel2;
input Accel2 : float;
input CruiseState2 : integer;

output CruiseSpeed2 : float;
input Speed2 : float;

var CurrentSpeed := Zero : float in
	loop
		emit CruiseSpeed2(CurrentSpeed);
		pause;
		trap T3 in
			% OFF STATE LOGIC
			if ?CruiseState2 = 1 then
				CurrentSpeed := Zero;
				exit T3;
			% ALL OTHER STATES
			else
				present Set2 then
					CurrentSpeed := ?Speed2;
					exit T3;
				end present;
				present QuickAccel2 then
					if CurrentSpeed < SpeedMaxi then
						CurrentSpeed := CurrentSpeed + SpeedInc;
						exit T3;
					end if;
				end present;
				present QuickDecel2 then
					if CurrentSpeed > SpeedMini then
						CurrentSpeed := CurrentSpeed - SpeedInc;
						exit T3;
					end if;
				end present;
				% IF JUST SWITCHED TO ON STATE, LOAD CURRENT SPEED
				if ((?CruiseState2 = 2) and (pre(?CruiseState2) = 1)) then
					CurrentSpeed := ?Speed2;
					exit T3;
				end if;
				exit T3;
			end if;
		end trap
	end loop
end var
end module

module ThrottleController:
    %{
        When the cruise control is off, the car speed shall be driven by the accelerator pedal.
        When the cruise control is on, the car speed shall be automatically regulated.
        The regulation shall be done using a proportional and integral algorithm, with Kp and Ki factors.
    }%

    % Inputs %
    input Accel_driving : float;
    input CruiseSpeed_driving : float;
    input State_driving : integer;
    input Speed_driving : float;
    output Throttle_driving : float;

    function regulateThrottle(integer, float, float) : float;

    loop
        pause;
        trap T_driving in
            if ?State_driving = 1 then
                emit Throttle_driving(?Accel_driving);
                exit T_driving;
            elsif ((?State_driving = 2) and (pre(?State_driving) = 1)) then
                emit Throttle_driving(regulateThrottle(1, ?CruiseSpeed_driving, ?Speed_driving));
                exit T_driving;
            elsif ?State_driving = 2 then
                emit Throttle_driving(regulateThrottle(0, ?CruiseSpeed_driving, ?Speed_driving));
                exit T_driving;
            else
                emit Throttle_driving(?Accel_driving);
                exit T_driving;
            end if;
        end trap
    end loop
end module
